<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>绚丽烟花秀 | 文字完全成型+5秒炸开+超大旋转角度+逐个延时+彩色文字</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            cursor: crosshair;
        }
        canvas {
            display: block;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
        }
    </style>
</head>
<body>
    <canvas id="fireworksCanvas"></canvas>
    <script>
        window.onload = function() {
            const canvas = document.getElementById('fireworksCanvas');
            const ctx = canvas.getContext('2d');
            resizeCanvas();
            // ========== ★★★ 自定义配置区 ★★★ 可直接修改 一键生效 ★★★ ==========
            const colors = [
                '255,99,71', '135,206,250', '50,205,50', '255,215,0', 
                '218,112,214', '255,140,0', '75,0,130', '255,20,147',
                '173,216,230', '240,128,128', '152,251,152', '255,228,181'
            ];
            const MAX_FIREWORKS = 25;          // 最大同时存在烟花数（防卡死）
            const GLOBAL_GRAVITY = 0.02;       // 粒子重力，下落更自然
            const SHOW_TEXT_DELAY = 8000;      // 文字粒子开始发射延迟 8秒
            const CUSTOM_TEXT = "新年快乐";    // ✅ 自定义文字，直接改！
            const TEXT_SIZE = 95;              // 文字大小，更醒目
            const TEXT_STAY_TIME = 5000;       // ✅ 文字成型后，精准展示5秒再炸
            const TEXT_PARTICLE_NUM = 180;     // 粒子更多，文字更饱满清晰
            const BLAST_SPEED = 3.0;           // 炸开速度，劲爆不拖沓
            const EMIT_DELAY = 3;              // ✅ 粒子逐个发射时延【毫秒】，越大发射越慢
            const ROTATE_RANGE = 240;          // ✅ 超大240°顺时针旋转角度，范围超开阔
            // ========== ★★★ 配置区结束 ★★★ ==========
            
            let fireworks = [];
            let textParticles = [];
            let blastParticles = [];
            let waitEmitParticles = [];        // 待发射粒子队列
            let isTextShow = false;
            let isTextFullyFormed = false;     // ✅ 新增核心标记：文字是否100%完全成型
            let textFullFormedTime = 0;        // ✅ 新增：文字成型的那一刻，才记录时间
            let emitTimer = null;

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', resizeCanvas);

            function Particle(x, y, color) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3.5 + 1.2;
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = Math.random() * 40 + 100;
                this.color = color;
                this.shape = Math.random() > 0.7 ? 'star' : (Math.random() > 0.5 ? 'circle' : 'line');
                this.size = Math.random() * 1.8 + 0.8;
                this.type = "firework";
            }

            // 彩色文字粒子 + 绑定顺时针旋转角度 + 目标坐标
            function TextParticle(x, y, targetX, targetY, angle) {
                this.x = x;
                this.y = y;
                this.targetX = targetX;
                this.targetY = targetY;
                this.speed = Math.random() * 1.6 + 1.8;
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.size = Math.random() * 2.8 + 1.8;
                this.type = "text";
                this.angle = angle;
                this.emitSpeed = Math.random() * 0.6 + 0.9;
            }

            // 同步彩色炸开：继承文字粒子颜色
            function BlastParticle(x, y, color) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * BLAST_SPEED + 1.8;
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = Math.random() * 70 + 100;
                this.color = color;
                this.size = Math.random() * 2.5 + 1.5;
                this.type = "blast";
            }

            function initFirework(customX = null, customHeight = null) {
                if(fireworks.length >= MAX_FIREWORKS) return;
                const x = customX || Math.random() * canvas.width;
                const y = canvas.height;
                const v = Math.random() * 5 + 3.5;
                const color = colors[Math.floor(Math.random() * colors.length)];
                const height = customHeight || Math.random() * canvas.height / 2 + canvas.height / 4;
                const particleNum = Math.floor(Math.random() * 80 + 120);
                fireworks.push({ x, y, v, color, height, particles: [], particleNum });
            }

            // 核心：生成顺时针旋转+待发射粒子队列
            function createTextParticles(text, fontSize, centerX, centerY) {
                textParticles = [];
                waitEmitParticles = [];
                blastParticles = [];
                isTextFullyFormed = false;      // ✅ 重置：每次重新发射都归零
                textFullFormedTime = 0;
                // 粒子发射原点：屏幕正下方绝对中心点
                const emitX = canvas.width / 2;
                const emitY = canvas.height + 20;

                const offScreenCanvas = document.createElement('canvas');
                const offScreenCtx = offScreenCanvas.getContext('2d');
                offScreenCanvas.width = canvas.width * 0.8;
                offScreenCanvas.height = fontSize * 2;
                offScreenCtx.font = `${fontSize}px bold 微软雅黑, sans-serif`;
                offScreenCtx.textAlign = 'center';
                offScreenCtx.textBaseline = 'middle';
                offScreenCtx.fillStyle = "white";
                offScreenCtx.fillText(text, offScreenCanvas.width/2, offScreenCanvas.height/2);

                const imageData = offScreenCtx.getImageData(0, 0, offScreenCanvas.width, offScreenCanvas.height);
                const pixels = imageData.data;
                const totalPoints = [];

                for (let y = 0; y < imageData.height; y += 3) {
                    for (let x = 0; x < imageData.width; x += 3) {
                        const index = (y * imageData.width + x) * 4;
                        const alpha = pixels[index + 3];
                        if (alpha > 150) {
                            const targetX = centerX - (offScreenCanvas.width/2 - x);
                            const targetY = centerY - (offScreenCanvas.height/2 - y);
                            totalPoints.push({x:targetX, y:targetY});
                        }
                    }
                }
                for(let i=0; i<TEXT_PARTICLE_NUM; i++){
                    const randomTargetIndex = Math.floor(Math.random() * totalPoints.length);
                    totalPoints.push(totalPoints[randomTargetIndex]);
                }

                // 240°超大顺时针旋转角度分配
                const totalParticleCount = totalPoints.length;
                const angleStep = ROTATE_RANGE / totalParticleCount;
                let currentAngle = Math.PI / 3; // 初始60°，旋转至300°，完美大扇形

                totalPoints.forEach((point, index) => {
                    waitEmitParticles.push(new TextParticle(emitX, emitY, point.x, point.y, currentAngle));
                    currentAngle += angleStep * Math.PI / 180;
                });

                startEmitParticle();
            }

            // 粒子逐个延时发射核心方法
            function startEmitParticle() {
                if(emitTimer) clearInterval(emitTimer);
                emitTimer = setInterval(() => {
                    if(waitEmitParticles.length > 0) {
                        const particle = waitEmitParticles.shift();
                        particle.x += Math.cos(particle.angle) * particle.emitSpeed;
                        particle.y += Math.sin(particle.angle) * particle.emitSpeed;
                        textParticles.push(particle);
                    } else {
                        clearInterval(emitTimer);
                    }
                }, EMIT_DELAY);
            }

            // ========== ✅ 核心修复逻辑【重中之重】：必须成型 → 再计时 → 再炸开 ==========
            function updateAllParticles() {
                // 烟花粒子逻辑不变
                for (let i = fireworks.length - 1; i >= 0; i--) {
                    const firework = fireworks[i];
                    if (firework.y > firework.height) {
                        firework.y -= firework.v;
                        ctx.beginPath();
                        ctx.arc(firework.x, firework.y, 2.5, 0, 2 * Math.PI);
                        ctx.fillStyle = `rgb(${firework.color})`;
                        ctx.fill();
                    } else {
                        if (firework.particles.length === 0) {
                            for (let j = 0; j < firework.particleNum; j++) {
                                firework.particles.push(new Particle(firework.x, firework.y, firework.color));
                            }
                        }
                        for (let j = firework.particles.length - 1; j >= 0; j--) {
                            const particle = firework.particles[j];
                            particle.x += particle.vx;
                            particle.y += particle.vy;
                            particle.vy += GLOBAL_GRAVITY;
                            particle.life--;
                            const alpha = particle.life / 140;
                            const rgba = `rgba(${particle.color},${alpha})`;
                            if (alpha > 0) drawParticle(particle, rgba, alpha);
                            if (particle.life <= 0) firework.particles.splice(j, 1);
                        }
                        if (firework.particles.length === 0) fireworks.splice(i, 1);
                    }
                }

                // ========== ✅ 关键修复：3重判定，确保文字100%成型 ==========
                if (isTextShow && blastParticles.length === 0) {
                    let allParticleArrived = true;
                    // 判定1：所有粒子都已经发射完毕（队列空了）
                    // 判定2：所有发射出去的粒子，都到达了目标坐标
                    for (let j = textParticles.length - 1; j >= 0; j--) {
                        const particle = textParticles[j];
                        const dx = particle.targetX - particle.x;
                        const dy = particle.targetY - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 2) {
                            particle.x += (dx / distance) * particle.speed;
                            particle.y += (dy / distance) * particle.speed;
                            allParticleArrived = false; // 有粒子没到位，就不算成型
                        } else {
                            particle.x = particle.targetX;
                            particle.y = particle.targetY;
                        }
                        // 彩色文字全程高亮，无衰减
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, 2 * Math.PI);
                        ctx.fillStyle = `rgba(${particle.color},1)`;
                        ctx.fill();
                    }

                    // ✅ 只有满足：队列空 + 所有粒子到位 → 才算【文字完全成型】
                    if(waitEmitParticles.length === 0 && allParticleArrived && !isTextFullyFormed){
                        isTextFullyFormed = true;
                        textFullFormedTime = Date.now(); // ✅ 成型瞬间，才开始计时！！！
                    }

                    // ✅ 核心规则：成型后计时5秒 → 精准炸开，绝不提前
                    if(isTextFullyFormed && Date.now() - textFullFormedTime >= TEXT_STAY_TIME){
                        [...textParticles, ...waitEmitParticles].forEach(item => {
                            blastParticles.push(new BlastParticle(item.x, item.y, item.color));
                        });
                        textParticles = [];
                        waitEmitParticles = [];
                        isTextShow = false;
                        isTextFullyFormed = false;
                    }
                }

                // 彩色炸开特效+重力下落+消散
                if (blastParticles.length > 0) {
                    for (let j = blastParticles.length - 1; j >= 0; j--) {
                        const particle = blastParticles[j];
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.vy += GLOBAL_GRAVITY;
                        particle.life--;
                        const alpha = particle.life / 150;
                        if (alpha > 0) {
                            ctx.beginPath();
                            ctx.arc(particle.x, particle.y, particle.size * alpha, 0, 2 * Math.PI);
                            ctx.fillStyle = `rgba(${particle.color},${alpha})`;
                            ctx.fill();
                        }
                        if (particle.life <= 0) blastParticles.splice(j, 1);
                    }
                    if(blastParticles.length === 0) blastParticles = [];
                }
            }

            function drawParticle(particle, rgba, alpha) {
                if (particle.shape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * alpha, 0, 2 * Math.PI);
                    ctx.fillStyle = rgba;
                    ctx.fill();
                } else if (particle.shape === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(particle.x, particle.y);
                    ctx.lineTo(particle.x - particle.vx * 2, particle.y - particle.vy * 2);
                    ctx.strokeStyle = rgba;
                    ctx.lineWidth = particle.size * alpha;
                    ctx.stroke();
                } else if (particle.shape === 'star') {
                    ctx.beginPath();
                    ctx.moveTo(particle.x, particle.y - particle.size);
                    ctx.lineTo(particle.x, particle.y + particle.size);
                    ctx.moveTo(particle.x - particle.size, particle.y);
                    ctx.lineTo(particle.x + particle.size, particle.y);
                    ctx.strokeStyle = rgba;
                    ctx.lineWidth = 1.2 * alpha;
                    ctx.stroke();
                }
            }

            function animate() {
                ctx.fillStyle = 'rgba(0,0,0,0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                updateAllParticles();
                requestAnimationFrame(animate);
            }

            // 点击发射烟花
            canvas.addEventListener('click', function(e) {
                initFirework(e.clientX, e.clientY);
            });
            const fireworkTimer = setInterval(initFirework, 180);

            // 定时触发粒子发射
            setTimeout(() => {
                isTextShow = true;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                createTextParticles(CUSTOM_TEXT, TEXT_SIZE, centerX, centerY);
                // ✅ 如需【无限循环播放】，取消下面注释即可
                setInterval(()=>{
                    isTextShow = true;
                    createTextParticles(CUSTOM_TEXT, TEXT_SIZE, centerX, centerY);
                }, SHOW_TEXT_DELAY + TEXT_STAY_TIME + 6000)
            }, SHOW_TEXT_DELAY);

            // 页面卸载清理
            window.addEventListener('beforeunload', () => {
                clearInterval(fireworkTimer);
                clearInterval(emitTimer);
                fireworks = [];textParticles=[];blastParticles=[];waitEmitParticles=[];
            });

            animate();
        };
    </script>
</body>
</html>